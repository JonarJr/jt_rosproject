#!/usr/bin/env python

#Created by Jonas Tjahjadi on 11/26/2017 as part of the ROS Programming Assignment

#imports
import rospy
#for actions and autogenerated messages
import actionlib
from geometry_msgs.msg import Twist
from ros_programming_assignment.msg import TwisterAction, TwisterGoal, TwisterResult, TwisterFeedback

class TwistAction():
	###FIELDS###	
	#current movement and publishing as Twist
	twist = Twist()
	#handle regular feedback
	feedback = TwisterFeedback()
	result = TwisterResult()
	#CHANGE FOR PRECISION YOU SEEK, USE A DEGREE/SECOND TO RADIAN/SECOND CONVERTER!
	#NOTE ON MATH: The increment_value is how many radians per second. So, we must convert to degrees/ 				second; 1 degree / second is 0.0174533 radian per second. This is how it'll get the exact 				degree turn. You can update this at your own risk! Just kidding. Easy to play around with.
	increment_value = 0.0174533
	sleep_value = 1

	#CONSTRUCTOR METHOD
	def __init__(self, name):
		self.server = actionlib.SimpleActionServer(name, TwisterAction, self.do_twist, False)
		self.server.start()
		
	#ACTION CALLBACK METHOD
	def do_twist(self, goal):
		#start movement to keep track of progress
		current_movement = 0
		#keeping track of how many times feedback is published
		update_count = 0
		
		#for action execution
		while current_movement < goal.movement or current_movement < -goal.movement:			
			#handle preemption from client requests
			self.handle_preemption(current_movement, update_count)
			
			#HANDLE NEGATIVE VS POSITIVE TURNS, what action should be done via publishing
			# to cmd_vel, and also what feedback it should be giving.
			if goal.movement > 0:
				#action update settings
				current_movement += self.increment_value / self.increment_value
				self.twist.angular.z = self.increment_value
				cmd_vel.publish(self.twist)
				#feedback settings
				self.feedback.movement_progress = current_movement
				self.feedback.movement_remaining = goal.movement - self.feedback.movement_progress
			else:
				#action update settings
				current_movement += self.increment_value / self.increment_value
				self.twist.angular.z = -(self.increment_value)
				cmd_vel.publish(self.twist)
				#feedback setting
				self.feedback.movement_progress = -current_movement
				self.feedback.movement_remaining = -(goal.movement - self.feedback.movement_progress)
	
			#publish feedback at a every degree turned
			self.server.publish_feedback(self.feedback)
			update_count += 1
			rospy.sleep(self.sleep_value)
			
		#stop and deliver results
		self.end_action_show_results(current_movement, update_count)
	
	#HELPER FUNCTIONS FOR ACTION CALLBACK
	def handle_preemption(self, preempted_movement, preempted_update_count):
		if self.server.is_preempt_requested():
				self.result = TwisterResult()
				self.result.movement_progress = preempted_movement
				self.result.updates_sent = preempted_update_count
				self.server.set_preempted(self.result, "Movement preempted")

	def end_action_show_results(self, resulted_movement, resulted_update_count):
		#action has been completed, stop and show results
		self.twist.angular.z = 0
		cmd_vel.publish(self.twist)
		self.result.movement_progress = resulted_movement
		self.result.updates_sent = resulted_update_count
		self.server.set_succeeded(self.result, "Movement completed successfully")
	
	
#INITIALIZE the node and start the server while node is running
if __name__ == '__main__':
	rospy.init_node('twister_action_server')
	cmd_vel = rospy.Publisher('cmd_vel', Twist, queue_size=1)
	TwistAction('twister')
	rospy.spin()
